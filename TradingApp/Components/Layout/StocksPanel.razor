@namespace TradingApp.Components
@using TradingApp.Models
@using TradingApp.Services
@using Microsoft.AspNetCore.Components.Authorization
@inject Stocks StockModel
@inject UserService UserService
@inject PortfolioService PortfolioService
@inject AuthenticationStateProvider AuthStateProvider
@implements IDisposable

<div class="stocks-grid">
  <aside class="stocks-list">
    <input class="stocks-search" @bind="search" placeholder="Search stock..." />

    <ul class="symbols">
      @foreach (var s in VisibleSymbols)
      {
        var q = Quotes.TryGetValue(s, out var qq) ? qq : null;
        <li @key="s">
          <div class="symbol-card @(s == Selected ? "active" : "")" @onclick="() => Selected = s">
            <div class="info">
              <div class="sym">@s.Split(':').Last()</div>
              @if (q is not null)
              {
                <div class="row">
                  <span class="price">$@q.Price.ToString("F2")</span>
                  <span class="chg @(q.Change >= 0 ? "up" : "down")">
                    @q.Change.ToString("F2") (@q.ChangePercent.ToString("F2")%)
                  </span>
                </div>
              }
            </div>

            <div class="actions">
              <button class="trade-btn buy" @onclick="() => OpenBuyModal(s)" @onclick:stopPropagation="true">
                <svg class="btn-icon" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                  <path d="M8.5 2.75a.75.75 0 0 0-1.5 0v4.5h-4.5a.75.75 0 0 0 0 1.5h4.5v4.5a.75.75 0 0 0 1.5 0v-4.5h4.5a.75.75 0 0 0 0-1.5h-4.5v-4.5Z" />
                </svg>
                <span class="btn-text">Buy</span>
              </button>
              <button class="trade-btn sell" @onclick="() => OpenSellModal(s)" @onclick:stopPropagation="true">
                <svg class="btn-icon" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                  <path d="M2 8.75A.75.75 0 0 1 2.75 8h10.5a.75.75 0 0 1 0 1.5H2.75A.75.75 0 0 1 2 8.75Z" />
                </svg>
                <span class="btn-text">Sell</span>
              </button>
            </div>
          </div>
        </li>
      }
    </ul>

    <div class="status" style="margin-top:.75rem">
      <div><small>Source: Live API (server)</small></div>
      <div><small>Last update: @_lastUpdated</small></div>
      @if (!string.IsNullOrEmpty(_lastError))
      {
        <div><small class="error">Error: @_lastError</small></div>
      }
    </div>
  </aside>

  <section class="stocks-view">
    <StockQuote Symbol="@Selected" Width="1200" Height="600" ColorTheme="light" />
  </section>
</div>

<TradingModal @ref="_tradingModal" OnTradeExecuted="HandleTradeExecuted" />
<TradeNotification @ref="_notification" />

@code {
    private string Selected = "NASDAQ:TSLA";
    private string search = "";
    private string? _lastUpdated = "(none yet)";
    private string? _lastError;

    private sealed class QuoteDto {
        public string Symbol { get; set; } = "";
        public double Price { get; set; }
        public double Change { get; set; }
        public double ChangePercent { get; set; }
        public bool IsUp { get; set; }
    }

    private readonly Dictionary<string, QuoteDto> Quotes = new();

    private readonly string[] Symbols = {
        "NASDAQ:TSLA","NASDAQ:AAPL","NASDAQ:MSFT","NASDAQ:NVDA",
        "NASDAQ:AMZN","NYSE:SPY","NYSE:KO","NYSE:DIS"
    };

    private IEnumerable<string> FilteredSymbols =>
        string.IsNullOrWhiteSpace(search)
            ? Symbols
            : Symbols.Where(s => s.Contains(search, StringComparison.OrdinalIgnoreCase));

    private IEnumerable<string> VisibleSymbols =>
        FilteredSymbols.Where(sym => Quotes.TryGetValue(sym, out var q) && q.Price > 0);

    protected override void OnInitialized() {
        foreach (var kv in StockModel.StockList) {
            var key = MapToDisplayKey(kv.Key);
            Quotes[key] = new QuoteDto {
                Symbol = key,
                Price = (double)kv.Value.Price,
                Change = 0,
                ChangePercent = 0,
                IsUp = true
            };
        }

        StockModel.PriceUpdated += OnPriceUpdatedFromServer;
    }

    private static string MapToDisplayKey(string bareSymbol) => bareSymbol switch {
        "SPY" => "NYSE:SPY",
        "KO"  => "NYSE:KO",
        "DIS" => "NYSE:DIS",
        _     => $"NASDAQ:{bareSymbol}"
    };

    private void OnPriceUpdatedFromServer(string bareSymbol, decimal newPrice) {
        var key = MapToDisplayKey(bareSymbol);

        if (!Quotes.TryGetValue(key, out var q)) {
            q = new QuoteDto { Symbol = key };
            Quotes[key] = q;
        }

        var prev = q.Price;
        q.Price = (double)newPrice;
        q.Change = Math.Round(q.Price - prev, 2);
        q.ChangePercent = prev == 0 ? 0 : Math.Round((q.Change / prev) * 100.0, 2);
        q.IsUp = q.Change >= 0;

        _lastUpdated = DateTime.Now.ToLongTimeString();

        // Ensure the selected item is one that is visible
        EnsureSelectedVisible();

        _ = InvokeAsync(StateHasChanged);
    }

    private void EnsureSelectedVisible() {
        if (!VisibleSymbols.Contains(Selected)) {
            var first = VisibleSymbols.FirstOrDefault();
            if (!string.IsNullOrEmpty(first))
                Selected = first;
        }
    }

    public void Dispose() {
        StockModel.PriceUpdated -= OnPriceUpdatedFromServer;
    }

    private TradingModal _tradingModal = null!;
    private TradeNotification _notification = null!;

    private void OpenBuyModal(string symbol) {
        if (Quotes.TryGetValue(symbol, out var quote)) {
            var stock = new Stock {
                Symbol = symbol.Split(':').Last(),
                Name   = symbol,
                Price  = (decimal)quote.Price,
                Change = (decimal)quote.Change,
                ChangePercent = (decimal)quote.ChangePercent
            };
            _tradingModal.OpenModal(stock, TradingModal.TradeType.Buy);
        }
    }

    private void OpenSellModal(string symbol) {
        if (Quotes.TryGetValue(symbol, out var quote)) {
            var stock = new Stock {
                Symbol = symbol.Split(':').Last(),
                Name   = symbol,
                Price  = (decimal)quote.Price,
                Change = (decimal)quote.Change,
                ChangePercent = (decimal)quote.ChangePercent
            };
            _tradingModal.OpenModal(stock, TradingModal.TradeType.Sell);
        }
    }

    /// <summary>
    /// Handles trade execution after user confirms in the TradingModal
    /// </summary>
    private async Task HandleTradeExecuted(TradingModal.TradeConfirmation trade) {
        try {
            Console.WriteLine($"Trade execution started: {trade.TradeType} {trade.Shares} shares of {trade.Stock.Symbol}");

            // Get the current authenticated user
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = await UserService.GetCurrentUserAsync(authState.User);

            if (user == null) {
                Console.WriteLine("Trade failed: User not authenticated");
                _notification.ShowError("Please log in to execute trades");
                return;
            }

            Console.WriteLine($"User authenticated: {user.Username} (ID: {user.Id})");

            // Convert decimal shares to integer quantity (rounding down)
            int quantity = (int)Math.Floor(trade.Shares);

            if (quantity <= 0) {
                Console.WriteLine($"Trade failed: Invalid quantity {quantity}");
                _notification.ShowError("Invalid quantity. Must be at least 1 share.");
                return;
            }

            Console.WriteLine($"Executing {trade.TradeType} for {quantity} shares at ${trade.PricePerShare}");

            bool success;
            if (trade.TradeType == TradingModal.TradeType.Buy) {
                success = await UserService.ExecuteBuyTrade(user, trade.Stock.Symbol, quantity);
                if (!success) {
                    Console.WriteLine($"Buy trade failed: Insufficient funds (Balance: ${user.CurrentCashBalance})");
                    _notification.ShowError($"Insufficient funds to complete purchase. Available: ${user.CurrentCashBalance:N2}");
                    return;
                }
                Console.WriteLine($"Buy trade successful! New balance: ${user.CurrentCashBalance}");
            } else {
                success = await UserService.ExecuteSellTrade(user, trade.Stock.Symbol, quantity);
                if (!success) {
                    Console.WriteLine($"Sell trade failed: Insufficient shares");
                    _notification.ShowError("Insufficient shares to complete sale");
                    return;
                }
                Console.WriteLine($"Sell trade successful! New balance: ${user.CurrentCashBalance}");
            }

            // Show success notification
            _notification.ShowTradeConfirmation(trade);

            // Notify portfolio service that a trade was executed
            // This will trigger the UserDashboard to refresh automatically
            Console.WriteLine("Notifying portfolio changed event...");
            PortfolioService.NotifyPortfolioChanged();

            Console.WriteLine("Trade execution completed successfully!");

        } catch (ArgumentException ex) {
            Console.WriteLine($"Trade execution error (ArgumentException): {ex.Message}");
            _notification.ShowError(ex.Message);
        } catch (Exception ex) {
            Console.WriteLine($"Trade execution error (Unexpected): {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            _notification.ShowError("An error occurred while processing the trade. Please try again.");
        }
    }
}